#!/usr/bin/env cosmic
-- test cosmic.doc module

local path = require("cosmo.path")
local spawn = require("cosmic.spawn")
local cosmo = require("cosmo")
local doc = require("cosmic.doc")

local cosmic = path.join(os.getenv("TEST_BIN"), "cosmic")
local tmpdir = os.getenv("TEST_TMPDIR")

local function write_temp(name: string, content: string): string
  local filepath = path.join(tmpdir, name)
  cosmo.Barf(filepath, content)
  return filepath
end

-- Test parsing module-level doc comment
local function test_parse_module_doc()
  local source = [[--- This is the module description
--- It spans multiple lines
local x = 1
]]
  local result = doc.parse(source, "test.tl")
  assert(result.module_doc, "should extract module doc")
  assert(result.module_doc:find("module description"), "should contain description")
  assert(result.module_doc:find("multiple lines"), "should contain all lines")
end
test_parse_module_doc()

-- Test parsing function with doc comment
local function test_parse_function_doc()
  local source = [[
--- Add two numbers together
--- @param a number the first number
--- @param b number the second number
--- @return number the sum
local function add(a: number, b: number): number
  return a + b
end
]]
  local result = doc.parse(source, "test.tl")
  assert(#result.functions == 1, "should find one function")
  local fn = result.functions[1]
  assert(fn.name == "add", "function name should be 'add'")
  assert(fn.description:find("Add two numbers"), "should have description")
  assert(#fn.params == 2, "should have two params")
  assert(fn.params[1].name == "a", "first param should be 'a'")
  assert(fn.params[1].param_type == "number", "first param type should be 'number'")
  assert(#fn.returns == 1, "should have one return")
  assert(fn.returns[1].return_type == "number", "return type should be 'number'")
end
test_parse_function_doc()

-- Test parsing record
local function test_parse_record()
  local source = [[
--- A point in 2D space
local record Point
  x: number
  y: number
end
]]
  local result = doc.parse(source, "test.tl")
  assert(#result.records == 1, "should find one record")
  assert(result.records[1].name == "Point", "record name should be 'Point'")
  assert(result.records[1].description:find("2D space"), "should have description")
end
test_parse_record()

-- Test parsing Example_* functions
local function test_parse_example()
  local source = [[
local function Example_basic()
  print("hello")
  -- Output:
  -- hello
end
]]
  local result = doc.parse(source, "test.tl")
  assert(#result.examples == 1, "should find one example")
  assert(result.examples[1].name == "Example_basic", "example name should match")
  -- doc.parse extracts output with trailing newline from comment lines
  assert(result.examples[1].expected_output:match("^hello"), "should extract expected output")
end
test_parse_example()

-- Test that Example_* functions are not included in regular functions
local function test_example_not_in_functions()
  local source = [[
local function Example_foo()
  print("test")
end

local function real_function()
  return 42
end
]]
  local result = doc.parse(source, "test.tl")
  assert(#result.functions == 1, "should only find one regular function")
  assert(result.functions[1].name == "real_function", "should be the non-example function")
  assert(#result.examples == 1, "should find one example")
end
test_example_not_in_functions()

-- Test render produces markdown
local function test_render_markdown()
  local source = [[--- Test module
local record Foo
  x: number
end

local function Example_usage()
  print("hello")
  -- Output:
  -- hello
end
]]
  local result = doc.parse(source, "mymodule.tl")
  local md = doc.render(result)
  assert(md:find("# mymodule"), "should have module header")
  assert(md:find("Test module"), "should have module description")
  assert(md:find("## Types"), "should have Types section")
  assert(md:find("### Foo"), "should have Foo record")
  assert(md:find("## Examples"), "should have Examples section")
  assert(md:find("```teal"), "should have teal code block")
end
test_render_markdown()

-- Test render_file with valid file
local function test_render_file()
  local input = write_temp("doc_test.tl", [[--- A test file
local function helper()
  return 1
end
]])
  local ok, md = doc.render_file(input)
  assert(ok, "render_file should succeed")
  assert(md:find("# doc_test"), "should have filename as header")
  assert(md:find("A test file"), "should have module doc")
end
test_render_file()

-- Test render_file with missing file
local function test_render_file_missing()
  local ok, err = doc.render_file("/nonexistent/file.tl")
  assert(not ok, "render_file should fail on missing file")
  assert(err:find("cannot open"), "should have error message")
end
test_render_file_missing()

-- Note: --doc CLI flag has been removed. Use the doc.render_file() function directly
-- or the gendoc.tl script for build-time documentation generation.

-- Test function without doc comment
local function test_function_no_doc()
  local source = [[
local function undocumented()
  return 42
end
]]
  local result = doc.parse(source, "test.tl")
  assert(#result.functions == 1, "should find function")
  assert(result.functions[1].description == nil, "should have no description")
  assert(#result.functions[1].params == 0, "should have no params")
end
test_function_no_doc()

-- Test multiple functions
local function test_multiple_functions()
  local source = [[
--- First function
local function first()
end

--- Second function
local function second()
end
]]
  local result = doc.parse(source, "test.tl")
  assert(#result.functions == 2, "should find two functions")
  assert(result.functions[1].name == "first", "first function")
  assert(result.functions[2].name == "second", "second function")
end
test_multiple_functions()

-- Test example title conversion
local function test_example_title()
  local source = [[
local function Example_foo_bar_baz()
  print("test")
end
]]
  local result = doc.parse(source, "test.tl")
  local md = doc.render(result)
  assert(md:find("### foo bar baz"), "should convert underscores to spaces in title")
end
test_example_title()

-- Test that actual library files have proper documentation
-- These tests verify that our source files have doc comments
local function test_embed_has_module_doc()
  local ok, md = doc.render_file("lib/cosmic/embed.tl")
  assert(ok, "should read embed.tl")
  -- Module should have a description after the header
  assert(md:find("# embed\n\n[^#]"), "embed.tl should have module description")
end
test_embed_has_module_doc()

local function test_embed_has_type_descriptions()
  local ok, md = doc.render_file("lib/cosmic/embed.tl")
  assert(ok, "should read embed.tl")
  -- EmbedResult should have a description, not just a bare header
  assert(md:find("### EmbedResult\n\n[^#]"), "EmbedResult should have description")
end
test_embed_has_type_descriptions()

local function test_spawn_has_type_descriptions()
  local ok, md = doc.render_file("lib/cosmic/spawn.tl")
  assert(ok, "should read spawn.tl")
  -- SpawnHandle should have a description
  assert(md:find("### SpawnHandle\n\n[^#]"), "SpawnHandle should have description")
end
test_spawn_has_type_descriptions()

local function test_fetch_has_module_description()
  local ok, md = doc.render_file("lib/cosmic/fetch.tl")
  assert(ok, "should read fetch.tl")
  -- Module should have a description after the header
  assert(md:find("# fetch\n\n[^#]"), "fetch.tl should have module description")
  -- Should describe what it does
  assert(md:find("HTTP fetch"), "should describe HTTP fetching")
end
test_fetch_has_module_description()

print("All doc tests passed!")
